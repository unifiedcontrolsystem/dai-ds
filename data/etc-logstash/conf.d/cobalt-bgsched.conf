input {
    file {
        path => "/var/log/bgsched.log"
        # This sets the type of these records, used to narrow the scope in the following filters.
        type => "bgsched"
        # For files that are new and have NOT been seen before, says to start reading from beginning of file.
        start_position => "beginning"
    }
}


filter {
     if [type] == "bgsched" {
         grok {
                match => { "message" => [ "%{DATA:timestamp} %{DATA:something} %{DATA:before} %{DATA:capture} %{GREEDYDATA:rest}" ] }
         }
     }
}

output {

    if [type] == "bgsched" {
        # Send all our bgsched events that did NOT match our grok pattern to null output
        if "_grokparsefailure" in [tags] {
                null {}
             }
             else {

                 if ([capture] == "adding") or
                    ([capture] == "modifying") or
                    ([capture] == "releasing")
                 {
                     rabbitmq {
                         id => "bgsched"
                         host => "loki-n1"
                         exchange => "cobalt"
                         exchange_type => "topic"
                         durable => false
                         key => "InputFromLogstashForReservationData"
                         codec => line { format => "bgsched %{timestamp} %{something} %{before} %{capture} %{rest}" }
                     }
                 }
             }
    }
}
