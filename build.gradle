// Copyright (C) 2018-2021 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0
//
buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.netflix.nebula:gradle-ospackage-plugin:1.12.2+'
    }
}

plugins {
    id 'nebula.ospackage' version '6.1.4'
}

apply plugin: 'nebula.rpm'
apply plugin: 'java'

/////////////////////////////////////////////////////////////////////////////////////////
// Build variables                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////
boolean INCLUDE_DEBIAN=Boolean.parseBoolean(System.getProperty("includeDebianPackages", "false"))

def gitVersionString() {
    def stdout = new ByteArrayOutputStream()
    exec {
        ignoreExitValue = true
        standardOutput = stdout
        commandLine "git", "--git-dir=${rootProject.projectDir}/.git", "describe", "--tags"
    }
    def version = stdout.toString().trim()
    return (version == null || version.isEmpty())?'0.0.0':version
}

def static pythonVersionString(String gitVersion) {
    String[] parts = gitVersion.split("-")
    String pyVersion = parts[0]
    if(parts.length > 1)
        pyVersion += ".dev" + parts[1]
    return pyVersion
}

def packageVersion = gitVersionString()
def packageRelease = '0'
if(packageVersion.split('-').length > 1)
    packageRelease = packageVersion.split('-')[1]
def pythonVersion = pythonVersionString(packageVersion)

// Dependent Package Versions (latest as of 12/5/2019)
def voltdb_version = '9.1.1'
def apache_version = '2.12.1'
def httpcomponents_version = '4.5.12'
def cliftonjson_version = '3.1.0'
def rabbitmq_version = '5.7.3'
def picocli_version = '4.1.1'
def commonsio_version = '2.6'
def gson_version = '2.8.6'
def spark_version = '2.9.1'
def postgres_jdbc_version = '42.2.8'
def slf4j_version = '1.7.29'
def commonslang3_version = '3.9'
def lombok_version = '1.18.16'
def spock_core_version = '1.3-groovy-2.4'
def cglib_nodep_version = '3.3.0'
def kafka_clients_version = '2.7.0'
def kafka_avro_serializer = '6.0.1'

/////////////////////////////////////////////////////////////////////////////////////////
// Developers and the CI must define the System property 'includeDebugSymbols' as      //
// 'true' either at the gradlew commandline or a better solution would be to add the   //
// following line to the ~/.gradle/gradle.properties file:                             //
//                                                                                     //
//     systemProp.includeDebugSymbols=true                                             //
//                                                                                     //
// The default behavior of 'false' will be for github default build behaviors.         //
/////////////////////////////////////////////////////////////////////////////////////////
def includeDbgSymbols = Boolean.parseBoolean(System.getProperty("includeDebugSymbols", "false"))

/////////////////////////////////////////////////////////////////////////////////////////

def enforceCodeCoverage = false


import java.nio.charset.StandardCharsets
import java.time.Instant
def thisYear = Instant.now().toDate().toYear().toString()

/////////////////////////////////////////////////////////////////////////////////////////
// Packaging and install variables                                                     //
/////////////////////////////////////////////////////////////////////////////////////////
def install_dir = "/opt/ucs"
def bin_dir     = install_dir + "/bin"
def etc_dir     = install_dir + "/etc"
def share_dir   = install_dir + "/share"
def lib_dir     = install_dir + "/lib"
def log_dir     = install_dir + "/log"
def docker_dir  = install_dir + "/docker"
def python_dir  = install_dir + "/python"

println("\n*** Build Version: " + packageVersion)
if(!includeDbgSymbols)
    System.err.println("*** Not including debug symbols!")

task rootClean(type: Delete) {
    delete "${projectDir}/out", "${projectDir}/build"
    delete += fileTree("${projectDir}").matching {
        include "*.log"
    }
    delete += fileTree("${rootProject.projectDir}").matching {
        include "**/build/**"
    }
}
clean.finalizedBy(rootClean)

/////////////////////////////////////////////////////////////////////////////////////////
// Root project and all project definitions                                            //
/////////////////////////////////////////////////////////////////////////////////////////
allprojects {
    version = ""
}

/////////////////////////////////////////////////////////////////////////////////////////
// Sub-project common definitions                                                       //
/////////////////////////////////////////////////////////////////////////////////////////
subprojects {
    apply plugin: 'groovy'
    apply plugin: 'java'
    apply plugin: 'idea'
    apply plugin: 'jacoco'

    repositories {
        mavenCentral()
        maven { url "https://packages.confluent.io/maven/" }
    }

    compileTestJava {
        options.compilerArgs <<'-Xlint:deprecation'
    }

    compileJava {
        if(!includeDbgSymbols)
            options.compilerArgs << '-g:none'
        options.compilerArgs << '-Werror'
        options.compilerArgs << '-Xlint:all,-path,-options'
        options.compilerArgs << '-Xlint:-processing'
        options.compilerArgs << '-XDignore.symbol.file=true'

        options.fork = true
        options.forkOptions.executable = 'javac'
    }

    dependencies {
        testCompile 'junit:junit:4.12+'
        testCompile group: 'org.mockito', name: 'mockito-core', version: '2.22+'
    }

    sourceCompatibility = 11
    targetCompatibility = 11

    jacoco {
        toolVersion = "0.8.5"
    }

    clean {
        delete += "out"
    }

    jar {
        doLast {
            copy {
                from outputs.files
                into "../build/jars"
            }
            copy {
                from outputs.files
                into "../build/libs"
            }
            copy {
                from configurations.compile
                into "../build/jars"
            }
        }
    }

    test {
        useJUnit()
        environment('XDG_CONFIG_DIRS', '/tmp')
        System.setProperty('daiLoggingLevel', 'debug')
        testLogging {
            showCauses = true
            showExceptions = true
            showStackTraces = true
            showStandardStreams = true
        }
        reports {
            html.destination = file("${rootProject.buildDir}/reports/tests/${project.name}")
        }

        finalizedBy "jacocoTestReport"
    }

    jacocoTestReport {
        group = "Build"
        reports {
            xml.enabled = true
            csv.enabled = false
            html.destination = file("${rootProject.buildDir}/reports/coverage/${project.name}")
            xml.destination = file("${rootProject.buildDir}/jacoco/jacocoTestResults-${project.name}.xml")
        }

        finalizedBy "jacocoTestCoverageVerification"
    }

    // Integration Tests (at Component Level)
    configurations {
        integrationImplementation.extendsFrom testImplementation
        integrationRuntime.extendsFrom testRuntime
    }

    sourceSets {
        integration {
            groovy.srcDir "$projectDir/src/integration/groovy"
            resources.srcDir "$projectDir/src/integration/resources"
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
        }
    }

    task integrationTest(type: Test) {
        testClassesDirs = sourceSets.integration.output.classesDirs
        classpath = sourceSets.integration.runtimeClasspath

        testLogging {
            outputs.upToDateWhen {false}
            showCauses = true
            showExceptions = true
            showStackTraces = true
            showStandardStreams = true
            exceptionFormat = 'full'
        }
    }
}
clean.dependsOn(subprojects.clean)

/////////////////////////////////////////////////////////////////////////////////////////
// Subproject build definitions                                                        //
/////////////////////////////////////////////////////////////////////////////////////////
project(':xdg') {
    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':properties') {
    targetCompatibility = 8
    sourceCompatibility = 8

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':logging') {
    dependencies {
        compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: apache_version
        compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: apache_version
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':runtime_utils') {
    apply plugin: 'groovy'

    dependencies {
        compile project(':properties')
        compile project(':logging')
        compile project(':config_io')
        compile project(':xdg')

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':config_io') {
    targetCompatibility = 8
    sourceCompatibility = 8

    dependencies {
        compile group: 'com.github.cliftonlabs', name: 'json-simple', version: cliftonjson_version
        compile project(':properties')
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':perflogging') {
    dependencies {
        compile group: 'org.voltdb', name: 'voltdbclient', version: voltdb_version

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jar {
        from {
            configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
        }
        manifest {
            attributes(
                    "Class-Path": configurations.compile.collect { it.getName() }.join(' '),
                    'Main-Class': "com.intel.perflogging.GenerateRasEvents")
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':procedures') {
    apply plugin: 'groovy'

    targetCompatibility = 8
    sourceCompatibility = 8

    dependencies {
        compileOnly group: 'org.voltdb', name: 'voltdb', version: voltdb_version
        compile project(':properties')
        compile project(':config_io')

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
        testCompile group: 'org.voltdb', name: 'voltdb', version: voltdb_version
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':authentication') {
    apply plugin: 'groovy'
    dependencies {
        compile project(':logging')
        compile project(':properties')
        compile project(':config_io')
        compile group: 'commons-io', name: 'commons-io', version: commonsio_version

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':networking') {
    apply plugin: 'groovy'

    dependencies {
        compile project(':logging')
        compile project(':properties')
        compile project(':config_io')
        compile project(":authentication")
        compile "com.rabbitmq:amqp-client:${rabbitmq_version}"
        compile group: 'commons-io', name: 'commons-io', version: commonsio_version
        compile group: 'org.apache.httpcomponents', name: 'httpclient', version: httpcomponents_version
        compile group: 'org.zeromq', name: 'jeromq', version: '0.5.1'
        compile group:'org.apache.kafka', name:'kafka-clients', version:kafka_clients_version
        compile group:'io.confluent', name:'kafka-avro-serializer', version:kafka_avro_serializer

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':dai_core') {
    apply plugin: 'application'
    apply plugin: 'groovy'

    dependencies {
        compile project(':xdg')
        compile project(':properties')
        compile project(':config_io')
        compile project(':logging')
        compile project(':networking')
        compile project(':perflogging')
        compile project(':runtime_utils')
        compile group: 'org.voltdb', name: 'voltdbclient', version: voltdb_version
        compile "com.rabbitmq:amqp-client:${rabbitmq_version}"
        compile group: 'info.picocli', name: 'picocli', version: picocli_version
        compile group: 'commons-io', name: 'commons-io', version: commonsio_version
        compile "com.google.code.gson:gson:${gson_version}"
        compile group: 'org.apache.commons', name: 'commons-collections4', version: '4.4'
        compile group: 'org.apache.commons', name: 'commons-lang3', version: commonslang3_version

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
        compileOnly "org.projectlombok:lombok:${lombok_version}"
        annotationProcessor "org.projectlombok:lombok:${lombok_version}"
    }

    project.mainClassName = 'com.intel.dai.AdapterDaiMgr'

    jar {
        manifest {
            attributes(
                    "Class-Path": configurations.compile.collect { it.getName() }.join(' '),
                    'Main-Class': project.mainClassName)
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.79
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.50
                }
            }
        }
    }

    distZip.doLast {
        delete {
            delete "${buildDir}/distributions/${project.name}-${packageVersion}.zip"
        }
    }
}

project(':control') {
    dependencies {
        compile project(':logging')
        compile project(':dai_core')
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':ui') {
    apply plugin: 'application'
    apply plugin: 'groovy'

    dependencies {
        compile project(':dai_core')
        compile project(':logging')
        compile project(':properties')
        compile project(':config_io')
        compile "com.sparkjava:spark-core:${spark_version}"
        compile group: 'org.apache.httpcomponents', name: 'httpclient', version: httpcomponents_version
        compile group: 'org.voltdb', name: 'voltdbclient', version: voltdb_version

        testCompile "com.despegar:spark-test:1.1.8"
        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }
    project.mainClassName = 'com.intel.dai.ui.AdapterUIRest'

    jar {
        from fileTree(dir: "${projectDir}/../demo", include: 'demo-v2/**')
        manifest {
            attributes(
                    "Class-Path": configurations.compile.collect { it.getName() }.join(' '),
                    'Main-Class': project.mainClassName)
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.89
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }

    distZip.doLast {
        delete {
            delete "${buildDir}/distributions/${project.name}-${packageVersion}.zip"
        }
    }
}

project(':populate_schema') {
    apply plugin: 'application'
    apply plugin: 'groovy'

    dependencies {
        compile project(':logging')
        compile project(':properties')
        compile project(':config_io')
        compile project(':dai_core')
        compile group: 'org.postgresql', name: 'postgresql', version: postgres_jdbc_version
        compileOnly group: 'org.voltdb', name: 'voltdb', version: voltdb_version

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }
    project.mainClassName = 'com.intel.dai.populate.OnlineTierDataLoaderApp'

    jar {
        manifest {
            attributes(
                    "Class-Path": configurations.compile.collect { it.getName() }.join(' '),
                    'Main-Class': project.mainClassName)
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }

    distZip.doLast {
        delete {
            delete "${buildDir}/distributions/${project.name}-${packageVersion}.zip"
        }
    }
}

project(':dai_network_listener') {
    apply plugin: 'groovy'

    dependencies {
        compile project(':logging')
        compile project(':networking')
        compile project(':dai_core')
        compile project(':properties')
        compile project(':config_io')

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.69
                }
            }
        }
    }
}

project(":provisioners") {
    apply plugin: 'groovy'

    dependencies {
        compile project(":xdg")
        compile project(':dai_core')
        compile project(':dai_network_listener')
        compile project(":foreign_bus")

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(":inventory") {
    apply plugin: 'groovy'

    dependencies {
        compile project(":xdg")
        compile project(':dai_core')
        compile project(':dai_network_listener')
        compile project(":foreign_bus")

        compile "com.google.code.gson:gson:${gson_version}"
        compile group: 'org.apache.commons', name: 'commons-lang3', version: commonslang3_version

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
        compileOnly "org.projectlombok:lombok:${lombok_version}"
        annotationProcessor "org.projectlombok:lombok:${lombok_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.60
                }
            }
        }
    }
}

project(":monitoring") {
    apply plugin: 'groovy'

    dependencies {
        compile project(":xdg")
        compile project(':dai_core')
        compile project(':dai_network_listener')
        compile project(":foreign_bus")

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(":ras") {
    apply plugin: 'groovy'

    dependencies {
        compile project(':logging')
        compile project(':control')
        compile project(':dai_core')

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.62
                }
            }
        }
    }
}

project(':foreign_bus') {
    apply plugin: 'groovy'

    dependencies {
        compile project(':logging')
        compile project(':dai_core')
        compile project(':networking')
        compile project(':runtime_utils')
        compile project(':properties')
        compile project(':config_io')
        compile group: 'org.slf4j', name: 'slf4j-simple', version: slf4j_version
        compile group: 'org.apache.httpcomponents', name: 'httpclient', version: httpcomponents_version
        compile "com.sparkjava:spark-core:${spark_version}"

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
        compileOnly "org.projectlombok:lombok:${lombok_version}"
        annotationProcessor "org.projectlombok:lombok:${lombok_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':fabric') {
    apply plugin: 'groovy'

    dependencies {
        compile project(':logging')
        compile project(":properties")
        compile project(":config_io")
        compile project(':dai_core')
        compile project(':networking')
        compile project(':foreign_bus')

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':resource_managers') {
    apply plugin: 'application'
    apply plugin: 'groovy'

    dependencies {
        compile project(':dai_core')
        compile project(':logging')
        compile project(':properties')
        compile project(':config_io')
        compile project(':runtime_utils')
        compile "commons-io:commons-io:${commonsio_version}" // Used by the Pbs and Slurm Adapters
        compile group: 'org.voltdb', name: 'voltdbclient', version: voltdb_version // Used directly by this component.

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }
    project.mainClassName = project.hasProperty("main") ? project.getProperty("main") : 'com.intel.dai.AdapterWlmCobalt'

    jar {
        manifest {
            attributes(
                    "Class-Path": configurations.compile.collect { it.getName() }.join(' '),
                    'Main-Class': project.mainClassName)
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

project(':eventsim') {
    apply plugin: 'application'
    apply plugin: 'groovy'

    dependencies {
        compile project(':dai_core')
        compile project(':logging')
        compile project(':properties')
        compile project(':config_io')
        compile project(':runtime_utils')
        compile project(":foreign_bus")

        testCompile "org.spockframework:spock-core:${spock_core_version}"
        testCompile "cglib:cglib-nodep:${cglib_nodep_version}"
    }

    targetCompatibility = 11
    sourceCompatibility = 11

    project.mainClassName = project.hasProperty("main") ? project.getProperty("main") : 'com.intel.dai.EventSimApp'

    jar {
        manifest {
            attributes(
                    "Class-Path": configurations.compile.collect { it.getName() }.join(' '),
                    'Main-Class': project.mainClassName)
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'METHOD'
                    minimum = 0.90
                }
            }
            rule {
                enabled = enforceCodeCoverage
                limit {
                    counter = 'BRANCH'
                    minimum = 0.70
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////
// Test the Python cli code (manual test)                                              //
/////////////////////////////////////////////////////////////////////////////////////////
task testPython(type: Exec) {
    new File((String) "${buildDir}/python").mkdirs()
    workingDir("${projectDir}/cli")
    ByteArrayOutputStream stream = new ByteArrayOutputStream()
    standardOutput = stream
    errorOutput = standardOutput
    commandLine("python3", "-m", "pytest", "-v", "--cov-config=.coveragerc", "--cov=cli", "--cov-report=term-missing",
    "--cov-report=xml:${buildDir}/python/results.xml", "--cov-report=html:${buildDir}/python/coverage-report",
    "--fulltrace", ".")
    doLast {
        String result = stream.toString(StandardCharsets.UTF_8)
        println(result)
        new File((String)"${buildDir}/python/results.txt").text = result
        delete fileTree("${projectDir}/cli/cli/__pycache__")
        delete fileTree("${projectDir}/cli/cli/src/__pycache__")
        delete fileTree("${projectDir}/cli/cli/src/tests/__pycache__")
    }
}

/////////////////////////////////////////////////////////////////////////////////////////
// Summarize coverage HTML                                                             //
/////////////////////////////////////////////////////////////////////////////////////////
task makeSummaryHtml(type: Exec) {
    dependsOn subprojects.jacocoTestReport
    workingDir = "${projectDir}"
    commandLine "python3", "${projectDir}/build-scripts/reportCoverage.py"
}
rootProject.test.finalizedBy(makeSummaryHtml)

/////////////////////////////////////////////////////////////////////////////////////////
// Java RPM Packaging                                                                  //
/////////////////////////////////////////////////////////////////////////////////////////
/*** New RPM and DEB files ***/
task cleanupDeb(type: Delete) {
    delete fileTree("build/distributions").matching {
        include "**/*.changes"
    }
}

task make3rdPartyDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/dai-postgres.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI PostgreSQL Docker service.
Requires=docker.service
After=docker.service

[Service]
RestartSec=10
Restart=always
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml down -v
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml rm -v
ExecStart=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml up
ExecStop=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml down -v

[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/postgres.yml").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
version: '2'
services:
  dai-postgres:
    network_mode: host
    image: postgres:11.4
    container_name: dai-postgres
    environment:
      - POSTGRES_DB=dai
      - POSTGRES_USER=dai
      - POSTGRES_PASSWORD=123@dai
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - "${docker_dir}/tier2/log:/var/log/postgresql"
      - "${docker_dir}/tier2/init.d:/docker-entrypoint-initdb.d"
      - "${docker_dir}/tier2/data/pgdata:/var/lib/postgresql/data/pgdata"
    restart: always
"""
        new File((String)"${buildDir}/tmp/dai-rabbitmq.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI RabbitMQ broker.
Requires=docker.service
After=docker.service

[Service]
RestartSec=10
Restart=always
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml down -v
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml rm -v
ExecStart=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml up
ExecStop=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml down -v

[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/rabbitmq.yml").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
version: '2'
services:
  dai-rabbitmq:
    network_mode: host
    image: rabbitmq:3.7-management
    container_name: dai-rabbitmq
    environment:
      - RABBITMQ_NODE_IP="0.0.0.0"
    restart: always
"""
        new File((String)"${buildDir}/tmp/dai-voltdb.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI VoltDB Docker service with schema.
Requires=docker.service
After=docker.service

[Service]
RestartSec=10
Restart=always
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml down -v
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml rm -v
ExecStart=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml up
ExecStop=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml down -v

[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/voltdb.yml").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
version: '2'
services:
  dai-voltdb:
    network_mode: host
    image: voltdb/voltdb-community:9.2.1
    entrypoint: /opt/voltdb/schema/voltdb-entrypoint.sh
    container_name: dai-voltdb
    hostname: am01-nmn.local
    environment:
      - HTTP_PORT=18080
    volumes:
      - "/etc/hosts:/etc/hosts"
      - "${etc_dir}:${etc_dir}"
      - "/opt/ucs/docker/tier1/log:/var/voltdb/voltdbroot/log"
      - "/opt/ucs/docker/tier1/init.d:/opt/voltdb/schema"
    restart: always

  dai-populate-schema:
    network_mode: host
    depends_on:
      - dai-voltdb
    image: openjdk:11.0.5-jdk
    entrypoint: /opt/voltdb/schema/populateSchema.sh
    container_name: dai-populate-schema
    environment:
      - DAI_LOGGING_LEVEL=DEBUG
    volumes:
      - "/opt/ucs/docker/tier1/log:/opt/ucs/log"
      - "/opt/ucs/docker/tier1/init.d:/opt/voltdb/schema"
      - "/opt/ucs/etc:/opt/ucs/etc"
      - "/opt/ucs/lib:/opt/ucs/lib"
    restart: 'no'
"""
        new File((String)"${buildDir}/tmp/populateSchema.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

HOSTNAME="\$(cat ${etc_dir}/volt.hostname)"
LOG="/opt/ucs/log/populate_schema.log"
ARGS="\$(cat ${etc_dir}/volt.ip) /opt/ucs/etc/SystemManifest.json /opt/ucs/etc/MachineConfig.json /opt/ucs/etc/RasEventMetaData.json"
JAR="/opt/ucs/lib/populate_schema.jar"
PROPS="-DdaiLoggingLevel=\${DAI_LOGGING_LEVEL}"

umask 077

java \${PROPS} -jar \${JAR} \${ARGS} 2>&1 | tee \${LOG}

exit \$?
"""
        new File((String)"${buildDir}/tmp/voltdb-entrypoint.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

LOGFILE="/var/voltdb/voltdbroot/log/voltdb-startup.log"
export HOSTNAME="\$(cat ${etc_dir}/volt.hostname)"

function is_running() {
  voltadmin validate >/dev/null 2>&1
  return \${?}
}

function add_jar_file() {
  sqlcmd --query="load classes \${1};" 2>&1 | tee -a "\${LOGFILE}"
  return \${?}
}

function add_sql_file() {
  sqlcmd <"\${1}" 2>&1 | tee -a "\${LOGFILE}"
  rv=\${?}
  [[ \${rv} -ne 0 ]] && echo "exec SetDbSchemaFailed 'Error: Loading SQL file \${1}!'" | sqlcmd 2>&1 | tee -a "\${LOGFILE}"
  return \${rv}
}

function wait_for_start() {
  is_running
  while [ \${?} -ne 0 ]; do is_running; done
}

function wait_for_stop() {
  is_running
  while [ \${?} -eq 0 ]; do sleep 5; is_running; done
}

umask 077

[[ -z "\${HTTP_PORT}" ]] && HTTP_PORT=8080
>"\${LOGFILE}"

cd /opt/voltdb/schema
JARS=\$(ls *.jar | sort)
echo "*** JAR Manifest:" | tee -a "\${LOGFILE}"
echo "\${JARS}" | tee -a "\${LOGFILE}"

SQLS=\$(ls *.sql | sort)
echo "*** SQL Files To Load:" | tee -a "\${LOGFILE}"
echo "\${SQLS}" | tee -a "\${LOGFILE}"
cd -

errors=0
echo "Initializing VoltDB..." | tee -a "\${LOGFILE}"
voltdb init --force -D /var/voltdb 2>&1 | tee -a "\${LOGFILE}"
errors=\$(expr \${errors} + \${?})

echo "*** Starting VoltDB..." | tee -a "\${LOGFILE}"
[[ \${errors} -eq 0 ]] && voltdb start -B -D /var/voltdb --count=1 --http=\${HTTP_PORT} 2>&1 | tee -a "\${LOGFILE}"
errors=\$(expr \${errors} + \${?})

echo "*** Waiting for VoltDB..." | tee -a "\${LOGFILE}"
wait_for_start
errors=\$(expr \${errors} + \${?})

echo "*** Loading jar file classes..." | tee -a "\${LOGFILE}"
for file in \$JARS; do
  [[ \${errors} -eq 0 ]] && add_jar_file "/opt/voltdb/schema/\${file}"
  errors=\$(expr \${errors} + \${?})
done

echo "*** Loading schema files..."
for file in \$SQLS; do
  [[ \$errors -eq 0 ]] && add_sql_file "/opt/voltdb/schema/\${file}"
  errors=\$(expr \${errors} + \${?})
done

echo "*** Waiting for VoltDB to finish..."
[[ \${errors} -eq 0 ]] && wait_for_stop
errors=\$(expr \${errors} + \${?})

exit \${errors}
"""
        new File((String)"${buildDir}/tmp/daemon-reload.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl daemon-reload
exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-3rd-party.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl stop dai-voltdb.service
/bin/systemctl stop dai-rabbitmq.service
/bin/systemctl stop dai-postgres.service
/bin/systemctl disable dai-voltdb.service
/bin/systemctl disable dai-rabbitmq.service
/bin/systemctl disable dai-postgres.service
exit \$?
"""
    }
    summary = 'DAI 3rd Party Dependency Docker Containers'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700
    packageName = 'dai-3rd-party'

    preUninstall  file("${buildDir}/tmp/preUninstall-3rd-party.sh")
    postUninstall file("${buildDir}/tmp/daemon-reload.sh")
    postInstall   file("${buildDir}/tmp/daemon-reload.sh")

    directory("${docker_dir}/tier2/log", 0700)
    directory("${docker_dir}/tier1/log", 0700)

    into("/")

    // Postgres setup
    from("${buildDir}/tmp/postgres.yml") {
        into("opt/ucs/docker")
    }
    from("${projectDir}/data/db/DAI-Tier2-Schema-Psql.sql") {
        into("opt/ucs/docker/tier2/init.d")
        fileMode(0644)
    }
    // RabbitMQ setup
    from("${buildDir}/tmp/rabbitmq.yml") {
        into("opt/ucs/docker")
    }
    //VoltDB setup
    from("${buildDir}/tmp/voltdb-entrypoint.sh") {
        into("opt/ucs/docker/tier1/init.d")
        fileMode(0700)
    }
    from("${buildDir}/jars/json-simple-3.1.0.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("json-simple-3.1.0.jar", "01-json-simple-3.1.0.jar")
    }
    from("${buildDir}/libs/properties.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("properties.jar", "20-properties.jar")
    }
    from("${buildDir}/libs/config_io.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("config_io.jar", "50-config_io.jar")
    }
    from("${buildDir}/libs/procedures.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("procedures.jar", "99-procedures.jar")
    }
    from("${projectDir}/data/db/DAI-Volt-Tables.sql") {
        into("opt/ucs/docker/tier1/init.d")
        rename("DAI-Volt-Tables.sql", "10-DAI-Volt-Tables.sql")
    }
    from("${projectDir}/data/db/DAI-Volt-Procedures.sql") {
        into("opt/ucs/docker/tier1/init.d")
        rename("DAI-Volt-Procedures.sql", "50-DAI-Volt-Procedures.sql")
    }
    from("${buildDir}/tmp/voltdb.yml") {
        into("opt/ucs/docker")
    }
    // Populate VoltDB
    from("${buildDir}/tmp/populateSchema.sh") {
        into("opt/ucs/docker/tier1/init.d")
        fileMode(0700)
    }
    // Services
    from("${buildDir}/tmp/dai-postgres.service") {
        into("etc/systemd/system")
    }
    from("${buildDir}/tmp/dai-voltdb.service") {
        into("etc/systemd/system")
    }
    from("${buildDir}/tmp/dai-rabbitmq.service") {
        into("etc/systemd/system")
    }
}

task make3rdPartyRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/dai-postgres.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI PostgreSQL Docker service.
Requires=docker.service
After=docker.service

[Service]
RestartSec=10
Restart=always
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml down -v
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml rm -v
ExecStart=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml up
ExecStop=/usr/bin/docker-compose -f /opt/ucs/docker/postgres.yml down -v

[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/postgres.yml").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
version: '2'
services:
  dai-postgres:
    network_mode: host
    image: postgres:11.4
    container_name: dai-postgres
    environment:
      - POSTGRES_DB=dai
      - POSTGRES_USER=dai
      - POSTGRES_PASSWORD=123@dai
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - "${docker_dir}/tier2/log:/var/log/postgresql"
      - "${docker_dir}/tier2/init.d:/docker-entrypoint-initdb.d"
      - "${docker_dir}/tier2/data/pgdata:/var/lib/postgresql/data/pgdata"
    restart: always
"""
        new File((String)"${buildDir}/tmp/dai-rabbitmq.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI RabbitMQ broker.
Requires=docker.service
After=docker.service

[Service]
RestartSec=10
Restart=always
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml down -v
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml rm -v
ExecStart=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml up
ExecStop=/usr/bin/docker-compose -f /opt/ucs/docker/rabbitmq.yml down -v

[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/rabbitmq.yml").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
version: '2'
services:
  dai-rabbitmq:
    network_mode: host
    image: rabbitmq:3.7-management
    container_name: dai-rabbitmq
    environment:
      - RABBITMQ_NODE_IP="0.0.0.0"
    restart: always
"""
        new File((String)"${buildDir}/tmp/dai-voltdb.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI VoltDB Docker service with schema.
Requires=docker.service
After=docker.service

[Service]
RestartSec=10
Restart=always
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml down -v
ExecStartPre=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml rm -v
ExecStart=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml up
ExecStop=/usr/bin/docker-compose -f /opt/ucs/docker/voltdb.yml down -v

[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/voltdb.yml").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
version: '2'
services:
  dai-voltdb:
    network_mode: host
    image: voltdb/voltdb-community:9.2.1
    entrypoint: /opt/voltdb/schema/voltdb-entrypoint.sh
    container_name: dai-voltdb
    environment:
      - HTTP_PORT=18080
    volumes:
      - "/etc/hosts:/etc/hosts"
      - "${etc_dir}:${etc_dir}"
      - "/opt/ucs/docker/tier1/log:/var/voltdb/voltdbroot/log"
      - "/opt/ucs/docker/tier1/init.d:/opt/voltdb/schema"
    restart: always

  dai-populate-schema:
    network_mode: host
    depends_on:
      - dai-voltdb
    image: openjdk:11.0.5-jdk
    entrypoint: /opt/voltdb/schema/populateSchema.sh
    container_name: dai-populate-schema
    environment:
      - DAI_LOGGING_LEVEL=DEBUG
    volumes:
      - "/opt/ucs/docker/tier1/log:/opt/ucs/log"
      - "/opt/ucs/docker/tier1/init.d:/opt/voltdb/schema"
      - "/opt/ucs/etc:/opt/ucs/etc"
      - "/opt/ucs/lib:/opt/ucs/lib"
    restart: 'no'
"""
        new File((String)"${buildDir}/tmp/populateSchema.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

HOSTNAME="\$(cat ${etc_dir}/volt.hostname)"
LOG="/opt/ucs/log/populate_schema.log"
ARGS="\$(cat ${etc_dir}/volt.ip) /opt/ucs/etc/SystemManifest.json /opt/ucs/etc/MachineConfig.json /opt/ucs/etc/RasEventMetaData.json"
JAR="/opt/ucs/lib/populate_schema.jar"
PROPS="-DdaiLoggingLevel=\${DAI_LOGGING_LEVEL}"

umask 077

java \${PROPS} -jar \${JAR} \${ARGS} 2>&1 | tee \${LOG}

exit \$?
"""
        new File((String)"${buildDir}/tmp/voltdb-entrypoint.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

LOGFILE="/var/voltdb/voltdbroot/log/voltdb-startup.log"
export HOSTNAME="\$(cat ${etc_dir}/volt.hostname)"

function is_running() {
  voltadmin validate >/dev/null 2>&1
  return \${?}
}

function add_jar_file() {
  sqlcmd --query="load classes \${1};" 2>&1 | tee -a "\${LOGFILE}"
  return \${?}
}

function add_sql_file() {
  sqlcmd <"\${1}" 2>&1 | tee -a "\${LOGFILE}"
  rv=\${?}
  [[ \${rv} -ne 0 ]] && echo "exec SetDbSchemaFailed 'Error: Loading SQL file \${1}!'" | sqlcmd 2>&1 | tee -a "\${LOGFILE}"
  return \${rv}
}

function wait_for_start() {
  is_running
  while [ \${?} -ne 0 ]; do is_running; done
}

function wait_for_stop() {
  is_running
  while [ \${?} -eq 0 ]; do sleep 5; is_running; done
}

umask 077

[[ -z "\${HTTP_PORT}" ]] && HTTP_PORT=8080
>"\${LOGFILE}"

cd /opt/voltdb/schema
JARS=\$(ls *.jar | sort)
echo "*** JAR Manifest:" | tee -a "\${LOGFILE}"
echo "\${JARS}" | tee -a "\${LOGFILE}"

SQLS=\$(ls *.sql | sort)
echo "*** SQL Files To Load:" | tee -a "\${LOGFILE}"
echo "\${SQLS}" | tee -a "\${LOGFILE}"
cd -

errors=0
echo "Initializing VoltDB..." | tee -a "\${LOGFILE}"
voltdb init --force -D /var/voltdb 2>&1 | tee -a "\${LOGFILE}"
errors=\$(expr \${errors} + \${?})

echo "*** Starting VoltDB..." | tee -a "\${LOGFILE}"
[[ \${errors} -eq 0 ]] && voltdb start -B -D /var/voltdb --count=1 --http=\${HTTP_PORT} 2>&1 | tee -a "\${LOGFILE}"
errors=\$(expr \${errors} + \${?})

echo "*** Waiting for VoltDB..." | tee -a "\${LOGFILE}"
wait_for_start
errors=\$(expr \${errors} + \${?})

echo "*** Loading jar file classes..." | tee -a "\${LOGFILE}"
for file in \$JARS; do
  [[ \${errors} -eq 0 ]] && add_jar_file "/opt/voltdb/schema/\${file}"
  errors=\$(expr \${errors} + \${?})
done

echo "*** Loading schema files..."
for file in \$SQLS; do
  [[ \$errors -eq 0 ]] && add_sql_file "/opt/voltdb/schema/\${file}"
  errors=\$(expr \${errors} + \${?})
done

echo "*** Waiting for VoltDB to finish..."
[[ \${errors} -eq 0 ]] && wait_for_stop
errors=\$(expr \${errors} + \${?})

exit \${errors}
"""
        new File((String)"${buildDir}/tmp/daemon-reload.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl daemon-reload
exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-3rd-party.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl stop dai-voltdb.service
/bin/systemctl stop dai-rabbitmq.service
/bin/systemctl stop dai-postgres.service
/bin/systemctl disable dai-voltdb.service
/bin/systemctl disable dai-rabbitmq.service
/bin/systemctl disable dai-postgres.service
exit \$?
"""
    }
    summary = 'DAI 3rd Party Dependency Docker Containers'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700
    packageName = 'dai-3rd-party'

    preUninstall  file("${buildDir}/tmp/preUninstall-3rd-party.sh")
    postUninstall file("${buildDir}/tmp/daemon-reload.sh")
    postInstall   file("${buildDir}/tmp/daemon-reload.sh")

    directory("${docker_dir}/tier2/log", 0700)
    directory("${docker_dir}/tier1/log", 0700)

    into("/")

    // Postgres setup
    from("${buildDir}/tmp/postgres.yml") {
        into("opt/ucs/docker")
    }
    from("${projectDir}/data/db/DAI-Tier2-Schema-Psql.sql") {
        into("opt/ucs/docker/tier2/init.d")
        fileMode(0644)
    }
    // RabbitMQ setup
    from("${buildDir}/tmp/rabbitmq.yml") {
        into("opt/ucs/docker")
    }
    //VoltDB setup
    from("${buildDir}/tmp/voltdb-entrypoint.sh") {
        into("opt/ucs/docker/tier1/init.d")
        fileMode(0700)
    }
    from("${buildDir}/jars/json-simple-3.1.0.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("json-simple-3.1.0.jar", "01-json-simple-3.1.0.jar")
    }
    from("${buildDir}/libs/properties.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("properties.jar", "20-properties.jar")
    }
    from("${buildDir}/libs/config_io.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("config_io.jar", "50-config_io.jar")
    }
    from("${buildDir}/libs/procedures.jar") {
        into("opt/ucs/docker/tier1/init.d")
        rename("procedures.jar", "99-procedures.jar")
    }
    from("${projectDir}/data/db/DAI-Volt-Tables.sql") {
        into("opt/ucs/docker/tier1/init.d")
        rename("DAI-Volt-Tables.sql", "10-DAI-Volt-Tables.sql")
    }
    from("${projectDir}/data/db/DAI-Volt-Procedures.sql") {
        into("opt/ucs/docker/tier1/init.d")
        rename("DAI-Volt-Procedures.sql", "50-DAI-Volt-Procedures.sql")
    }
    from("${buildDir}/tmp/voltdb.yml") {
        into("opt/ucs/docker")
    }
    // Populate VoltDB
    from("${buildDir}/tmp/populateSchema.sh") {
        into("opt/ucs/docker/tier1/init.d")
        fileMode(0700)
    }
    // Services
    from("${buildDir}/tmp/dai-postgres.service") {
        into("etc/systemd/system")
    }
    from("${buildDir}/tmp/dai-voltdb.service") {
        into("etc/systemd/system")
    }
    from("${buildDir}/tmp/dai-rabbitmq.service") {
        into("etc/systemd/system")
    }
}

task makeVoltDBSchemaSetupDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/setupVoltDbSchema.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

echo "*** NOTE: This script and referenced collateral must be installed on the same"
echo "          system that VoltDB is installed on in order to setup VoltDB. VoltDB"
echo "          requires that SQL files and JAR files be on the same local system."
echo

which sqlcmd >/dev/null
if [ \$? -ne 0 ]; then
  echo "ERROR: Missing 'sqlcmd' application in PATH!" >&2
  exit 1
fi

umask 077
cd ${share_dir}/for_voltdb
JARS="\$(/bin/ls *.jar | /usr/bin/sort)"
SQLS="\$(/bin/ls *.sql | /usr/bin/sort)"

for jar in \${JARS}; do
  fulljar="\$(pwd)/\${jar}"
  echo "*** Installing JAR Fail: \${fulljar}..."
  echo "load \${fulljar};" | sqlcmd --servers=127.0.0.1
done

for sql in \${SQLS}; do
  fullsql="\$(pwd)/\${sql}"
  echo "*** Installing SQL File: \${fullsql}..."
  echo "file \${fullsql};" | sqlcmd --servers=127.0.0.1
done

exit \$?
"""
    }
    summary = 'The DAI VoltDB Schema Setup installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700
    packageName = 'dai-volt-schema'

    into("/")

    from("${buildDir}/tmp/setupVoltDbSchema.sh") {
        into("${share_dir}/for_voltdb")
        fileMode = 0700
    }
    from("${projectDir}/data/db/DAI-Volt-Tables.sql") {
        into("${share_dir}/for_voltdb")
        rename("DAI-Volt-Tables.sql","20-DAI-Volt-Tables.sql")
    }
    from("${projectDir}/data/db/DAI-Volt-Procedures.sql") {
        into("${share_dir}/for_voltdb")
        rename("DAI-Volt-Procedures.sql","40-DAI-Volt-Procedures.sql")
    }
    from("${buildDir}/jars/json-simple-3.1.0.jar") {
        into("${share_dir}/for_voltdb")
        rename("json-simple-3.1.0.jar", "00-json-simple-3.1.0.jar")
    }
    from("${buildDir}/libs/properties.jar") {
        into("${share_dir}/for_voltdb")
        rename("properties.jar", "20-properties.jar")
    }
    from("${buildDir}/libs/config_io.jar") {
        into("${share_dir}/for_voltdb")
        rename("config_io.jar", "60-config_io.jar")
    }
    from("${buildDir}/libs/procedures.jar") {
        into("${share_dir}/for_voltdb")
        rename("procedures.jar", "99-procedures.jar")
    }
}

task makeVoltDBSchemaSetupRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/setupVoltDbSchema.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

echo "*** NOTE: This script and referenced collateral must be installed on the same"
echo "          system that VoltDB is installed on in order to setup VoltDB. VoltDB"
echo "          requires that SQL files and JAR files be on the same local system."
echo

which sqlcmd >/dev/null
if [ \$? -ne 0 ]; then
  echo "ERROR: Missing 'sqlcmd' application in PATH!" >&2
  exit 1
fi

umask 077
cd ${share_dir}/for_voltdb
JARS="\$(/bin/ls *.jar | /usr/bin/sort)"
SQLS="\$(/bin/ls *.sql | /usr/bin/sort)"

for jar in \${JARS}; do
  fulljar="\$(pwd)/\${jar}"
  echo "*** Installing JAR Fail: \${fulljar}..."
  echo "load \${fulljar};" | sqlcmd --servers=127.0.0.1
done

for sql in \${SQLS}; do
  fullsql="\$(pwd)/\${sql}"
  echo "*** Installing SQL File: \${fullsql}..."
  echo "file \${fullsql};" | sqlcmd --servers=127.0.0.1
done

exit \$?
"""
    }
    summary = 'The DAI VoltDB Schema Setup installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700
    packageName = 'dai-volt-schema'

    into("/")

    from("${buildDir}/tmp/setupVoltDbSchema.sh") {
        into("${share_dir}/for_voltdb")
        fileMode = 0700
    }
    from("${projectDir}/data/db/DAI-Volt-Tables.sql") {
        into("${share_dir}/for_voltdb")
        rename("DAI-Volt-Tables.sql","20-DAI-Volt-Tables.sql")
    }
    from("${projectDir}/data/db/DAI-Volt-Procedures.sql") {
        into("${share_dir}/for_voltdb")
        rename("DAI-Volt-Procedures.sql","40-DAI-Volt-Procedures.sql")
    }
    from("${buildDir}/jars/json-simple-3.1.0.jar") {
        into("${share_dir}/for_voltdb")
        rename("json-simple-3.1.0.jar", "00-json-simple-3.1.0.jar")
    }
    from("${buildDir}/libs/properties.jar") {
        into("${share_dir}/for_voltdb")
        rename("properties.jar", "20-properties.jar")
    }
    from("${buildDir}/libs/config_io.jar") {
        into("${share_dir}/for_voltdb")
        rename("config_io.jar", "60-config_io.jar")
    }
    from("${buildDir}/libs/procedures.jar") {
        into("${share_dir}/for_voltdb")
        rename("procedures.jar", "99-procedures.jar")
    }
}

task makePostgresSchemaSetupDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/setupInitialPostgresSchema.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

which psql >/dev/null
if [ \$? -ne 0 ]; then
  echo "ERROR: Missing 'psql' application in PATH!" >&2
  exit 1
fi

if [ "\${1}" = "-h" -o "\${1}" = "--help" ]; then
  echo "Usage: \$(basename \${0}) [dbname [username]]
  exit 0
fi

user=dai
db=dai

[[ -n "\${1}" ]] && db="\${1}" && shift 
[[ -n "\${1}" ]] && user="\${1}" && shift

cd ${share_dir}/for_postgres

psql -U \${user} \${db} <./DAI-Tier2-Schema-Psql.sql

exit \$?
"""
    }
    summary = 'The DAI Postgres Schema Setup installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700
    packageName = 'dai-postgres-schema'

    into("/")

    // For Postgres
    from("${projectDir}/data/DAI-schema-migration") {
        into("${share_dir}/for_postgres/schema-migration")
    }
    from("${projectDir}/data/db/DAI-Tier2-Schema-Psql.sql") {
        into("${share_dir}/for_postgres")
    }
    from("${buildDir}/tmp/setupInitialPostgresSchema.sh") {
        into("${share_dir}/for_postgres")
        fileMode(0700)
    }
}

task makePostgresSchemaSetupRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/setupInitialPostgresSchema.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

which psql >/dev/null
if [ \$? -ne 0 ]; then
  echo "ERROR: Missing 'psql' application in PATH!" >&2
  exit 1
fi

if [ "\${1}" = "-h" -o "\${1}" = "--help" ]; then
  echo "Usage: \$(basename \${0}) [dbname [username]]
  exit 0
fi

user=dai
db=dai

[[ -n "\${1}" ]] && db="\${1}" && shift 
[[ -n "\${1}" ]] && user="\${1}" && shift

cd ${share_dir}/for_postgres

psql -U \${user} \${db} <./DAI-Tier2-Schema-Psql.sql

exit \$?
"""
    }
    summary = 'The DAI Postgres Schema Setup installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700
    packageName = 'dai-postgres-schema'

    into("/")

    // For Postgres
    from("${projectDir}/data/DAI-schema-migration") {
        into("${share_dir}/for_postgres/schema-migration")
    }
    from("${projectDir}/data/db/DAI-Tier2-Schema-Psql.sql") {
        into("${share_dir}/for_postgres")
    }
    from("${buildDir}/tmp/setupInitialPostgresSchema.sh") {
        into("${share_dir}/for_postgres")
        fileMode(0700)
    }
}

task makeDaiDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/dai-manager.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI Manager Service
[Service]
TasksMax=8192
Type=simple
User=root
WorkingDirectory=/tmp
EnvironmentFile=/opt/ucs/etc/dai.environment
ExecStart=/opt/ucs/bin/dai-manager
RestartSec=10
Restart=always
[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/dai.environment").text = """DAI_LOGGING_LEVEL=DEBUG
DAI_USE_BENCHMARKING=false"""
        new File((String)"${buildDir}/tmp/dai-manager").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

set -x

[[ -z "\${DAI_LOGGING_LEVEL}" ]] && DAI_LOGGING_LEVEL=DEBUG

MACHINECONFIG=${etc_dir}/MachineConfig.json
HOSTNAME=\$(hostname -A | awk '{print \$1}')
VOLTSERVERS=\$(cat ${etc_dir}/volt.ip)
CLASS="com.intel.dai.AdapterDaiMgr"
LOCATION=\$(/opt/voltdb/bin/sqlcmd --servers="\${VOLTSERVERS}" --output-skip-metadata --query="select lctn from servicenode where hostname='\${HOSTNAME}';" | sed 's/[\\n ]*//g')
LOGNAME="AdapterDaiMgr-\${LOCATION}.log"

if [ -z "\${LOCATION}" ]; then
  echo "ERROR: failed to get a valid location from the hostname: \${HOSTNAME}" >${log_dir}/\${LOGNAME} 2>&1
  exit 1
fi

java -DdaiLoggingLevel="\${DAI_LOGGING_LEVEL}" -cp '${lib_dir}/*' \${CLASS} \${VOLTSERVERS} \${LOCATION} \${HOSTNAME} >${log_dir}/\${LOGNAME} 2>&1

exit \$?
"""
        new File((String)"${buildDir}/tmp/daemon-reload.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl daemon-reload
exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-dai.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl stop dai-manager.service
/bin/systemctl disable dai-manager.service
exit \$?
"""
        new File((String)"${buildDir}/tmp/show-adapters").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

jps -l | grep "com.intel.dai."
exit 0
"""
        new File((String)"${buildDir}/tmp/loadVoltDbInitialData.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
LOG="/opt/ucs/log/populate_schema.log"
SERVERS="\$(cat ${etc_dir}/volt.ip)"
ARGS="\${SERVERS} ${etc_dir}/SystemManifest.json ${etc_dir}/MachineConfig.json ${etc_dir}/RasEventMetaData.json"
JAR="${lib_dir}/populate_schema.jar"
PROPS="-DdaiLoggingLevel=\${DAI_LOGGING_LEVEL}"

java \${PROPS} -jar \${JAR} \${ARGS} 2>&1 | tee \${LOG}

exit \$?
"""
    }
    summary = 'The DAI (Data Access Interface) for HPC or Cloud Clusters.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai"

    preUninstall  file("${buildDir}/tmp/preUninstall-dai.sh")
    postUninstall file("${buildDir}/tmp/daemon-reload.sh")
    postInstall   file("${buildDir}/tmp/daemon-reload.sh")

    directory(log_dir, 0700)

    into("/")

    // Service
    from("${buildDir}/tmp/dai-manager.service") {
        into("/etc/systemd/system")
        fileMode = 0644
    }
    from("${buildDir}/tmp/dai.environment") {
        into(etc_dir)
        fileMode = 0644
    }
    from("${buildDir}/tmp/dai-manager") {
        into(bin_dir)
        fileMode = 0700
    }
    // DAI Jars
    from ("${buildDir}/jars") {
        into(lib_dir)
        exclude "**/procedures.jar", "**/eventsim.jar"
    }
    // For VoltDB
    from("${buildDir}/tmp/loadVoltDbInitialData.sh") {
        into("${share_dir}/for_voltdb")
        fileMode = 0700
    }
    // Misc.
    from("${buildDir}/tmp/show-adapters") {
        into(bin_dir)
        fileMode = 0755
    }

    link("/usr/bin/show-adapters", "${bin_dir}/show-adapters")
}

task makeDaiRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/dai-manager.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI Manager Service
[Service]
TasksMax=8192
Type=simple
User=root
WorkingDirectory=/tmp
EnvironmentFile=/opt/ucs/etc/dai.environment
ExecStart=/opt/ucs/bin/dai-manager
RestartSec=10
Restart=always
[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/dai.environment").text = """DAI_LOGGING_LEVEL=DEBUG
DAI_USE_BENCHMARKING=false"""
        new File((String)"${buildDir}/tmp/dai-manager").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

set -x

[[ -z "\${DAI_LOGGING_LEVEL}" ]] && DAI_LOGGING_LEVEL=DEBUG

MACHINECONFIG=${etc_dir}/MachineConfig.json
HOSTNAME=\$(hostname -A | awk '{print \$1}')
VOLTSERVERS=\$(cat ${etc_dir}/volt.ip)
CLASS="com.intel.dai.AdapterDaiMgr"
LOCATION=\$(/opt/voltdb/bin/sqlcmd --servers="\${VOLTSERVERS}" --output-skip-metadata --query="select lctn from servicenode where hostname='\${HOSTNAME}';" | sed 's/[\\n ]*//g')
LOGNAME="AdapterDaiMgr-\${LOCATION}.log"

if [ -z "\${LOCATION}" ]; then
  echo "ERROR: failed to get a valid location from the hostname: \${HOSTNAME}" >${log_dir}/\${LOGNAME} 2>&1
  exit 1
fi

java -DdaiLoggingLevel="\${DAI_LOGGING_LEVEL}" -cp '${lib_dir}/*' \${CLASS} \${VOLTSERVERS} \${LOCATION} \${HOSTNAME} >${log_dir}/\${LOGNAME} 2>&1

exit \$?
"""
        new File((String)"${buildDir}/tmp/daemon-reload.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl daemon-reload
exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-dai.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl stop dai-manager.service
/bin/systemctl disable dai-manager.service
exit \$?
"""
        new File((String)"${buildDir}/tmp/show-adapters").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

jps -l | grep "com.intel.dai."
exit 0
"""
        new File((String)"${buildDir}/tmp/loadVoltDbInitialData.sh").text = """#!/usr/bin/env bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
LOG="/opt/ucs/log/populate_schema.log"
SERVERS="\$(cat ${etc_dir}/volt.ip)"
ARGS="\${SERVERS} ${etc_dir}/SystemManifest.json ${etc_dir}/MachineConfig.json ${etc_dir}/RasEventMetaData.json"
JAR="${lib_dir}/populate_schema.jar"
PROPS="-DdaiLoggingLevel=\${DAI_LOGGING_LEVEL}"

java \${PROPS} -jar \${JAR} \${ARGS} 2>&1 | tee \${LOG}

exit \$?
"""
    }
    summary = 'The DAI (Data Access Interface) for HPC or Cloud Clusters.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai"

    preUninstall  file("${buildDir}/tmp/preUninstall-dai.sh")
    postUninstall file("${buildDir}/tmp/daemon-reload.sh")
    postInstall   file("${buildDir}/tmp/daemon-reload.sh")

    directory(log_dir, 0700)

    into("/")

    // Service
    from("${buildDir}/tmp/dai-manager.service") {
        into("/etc/systemd/system")
        fileMode = 0644
    }
    from("${buildDir}/tmp/dai.environment") {
        into(etc_dir)
        fileMode = 0644
    }
    from("${buildDir}/tmp/dai-manager") {
        into(bin_dir)
        fileMode = 0700
    }
    // DAI Jars
    from ("${buildDir}/jars") {
        into(lib_dir)
        exclude "**/procedures.jar", "**/eventsim.jar"
    }
    // For VoltDB
    from("${buildDir}/tmp/loadVoltDbInitialData.sh") {
        into("${share_dir}/for_voltdb")
        fileMode = 0700
    }
    // Misc.
    from("${buildDir}/tmp/show-adapters") {
        into(bin_dir)
        fileMode = 0755
    }

    link("/usr/bin/show-adapters", "${bin_dir}/show-adapters")
}

task makeEventSimConfigDeb(type: Deb) {
    summary = 'The DAI EventSim Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-eventsim-config"

    into("/")

    from("${projectDir}/configurations/eventsim") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeEventSimConfigRpm(type: Rpm) {
    summary = 'The DAI EventSim Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-eventsim-config"

    into("/")

    from("${projectDir}/configurations/eventsim") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeHw1ConfigDeb(type: Deb) {
    summary = 'The DAI HW1 Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-hw1-config"

    into("/")

    from("${projectDir}/configurations/hw1") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeHw1ConfigRpm(type: Rpm) {
    summary = 'The DAI HW1 Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-hw1-config"

    into("/")

    from("${projectDir}/configurations/hw1") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeHw2ConfigDeb(type: Deb) {
    summary = 'The DAI HW2 Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-hw2-config"

    into("/")

    from("${projectDir}/configurations/hw2") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeHw2ConfigRpm(type: Rpm) {
    summary = 'The DAI HW2 Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-hw2-config"

    into("/")

    from("${projectDir}/configurations/hw2") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeHw3ConfigDeb(type: Deb) {
    summary = 'The DAI HW3 Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-hw3-config"

    into("/")

    from("${projectDir}/configurations/hw3") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeHw3ConfigRpm(type: Rpm) {
    summary = 'The DAI HW3 Configuration.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-hw3-config"

    into("/")

    from("${projectDir}/configurations/hw3") {
        into(etc_dir)
    }
    from("${projectDir}/configurations/common") {
        into(etc_dir)
    }
}

task makeEventSimServerDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/eventsim-server").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

[[ -z "\${DAI_LOGGING_LEVEL}" ]] && DAI_LOGGING_LEVEL="DEBUG"

LOG="/opt/ucs/log/EventSim-Server.log"
ARGS="\$(cat ${etc_dir}/volt.ip) /opt/ucs/etc/EventSim.json"
CLASS=com.intel.dai.eventsim.EventSimApp
PROPS="-DdaiLoggingLevel=\${DAI_LOGGING_LEVEL}"

mkdir -p /opt/ucs
echo "*** Logging level: \${DAI_LOGGING_LEVEL}" | tee \${LOG}
echo | tee -a \${LOG}

java -cp '/opt/ucs/lib/*' \${PROPS} \${CLASS} \${ARGS} 2>&1 | tee -a \${LOG}
"""
        new File((String)"${buildDir}/tmp/dai-eventsim.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI EventSim Service
[Service]
TasksMax=8192
Type=simple
User=root
WorkingDirectory=/tmp
EnvironmentFile=/opt/ucs/etc/dai.environment
ExecStart=/opt/ucs/bin/eventsim-server
RestartSec=10
Restart=always
[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/eventsim-server.environment").text = """DAI_LOGGING_LEVEL=DEBUG
"""
        new File((String)"${buildDir}/tmp/daemon-reload.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl daemon-reload
exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-dai-eventsim.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl stop dai-eventsim.service
/bin/systemctl disable dai-eventsim.service
exit \$?
"""
    }
    summary = 'The DAI EventSim Server Installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-eventsim-server"

    preUninstall  file("${buildDir}/tmp/preUninstall-dai-eventsim.sh")
    postUninstall file("${buildDir}/tmp/daemon-reload.sh")
    postInstall   file("${buildDir}/tmp/daemon-reload.sh")

    into("/")

    from("${buildDir}/libs/eventsim.jar") {
        into("${lib_dir}")
    }
    from("${buildDir}/tmp/eventsim-server") {
        into(bin_dir)
        fileMode(0755)
    }
    from("${buildDir}/tmp/dai-eventsim.service") {
        into("/etc/systemd/system")
        fileMode = 0644
    }
    from("${buildDir}/tmp/eventsim-server.environment") {
        into(etc_dir)
        fileMode = 0644
    }

    link("/usr/bin/eventsim-server","${bin_dir}/eventsim-server")
}

task makeEventSimServerRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/eventsim-server").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

[[ -z "\${DAI_LOGGING_LEVEL}" ]] && DAI_LOGGING_LEVEL="DEBUG"

LOG="/opt/ucs/log/EventSim-Server.log"
ARGS="\$(cat ${etc_dir}/volt.ip) /opt/ucs/etc/EventSim.json"
CLASS=com.intel.dai.eventsim.EventSimApp
PROPS="-DdaiLoggingLevel=\${DAI_LOGGING_LEVEL}"

mkdir -p /opt/ucs
echo "*** Logging level: \${DAI_LOGGING_LEVEL}" | tee \${LOG}
echo | tee -a \${LOG}

java -cp '/opt/ucs/lib/*' \${PROPS} \${CLASS} \${ARGS} 2>&1 | tee -a \${LOG}
"""
        new File((String)"${buildDir}/tmp/dai-eventsim.service").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
[Unit]
Description=DAI EventSim Service
[Service]
TasksMax=8192
Type=simple
User=root
WorkingDirectory=/tmp
EnvironmentFile=/opt/ucs/etc/dai.environment
ExecStart=/opt/ucs/bin/eventsim-server
RestartSec=10
Restart=always
[Install]
WantedBy=multi-user.target
"""
        new File((String)"${buildDir}/tmp/eventsim-server.environment").text = """DAI_LOGGING_LEVEL=DEBUG
"""
        new File((String)"${buildDir}/tmp/daemon-reload.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl daemon-reload
exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-dai-eventsim.sh").text = """# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
/bin/systemctl stop dai-eventsim.service
/bin/systemctl disable dai-eventsim.service
exit \$?
"""
    }
    summary = 'The DAI EventSim Server Installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-eventsim-server"

    preUninstall  file("${buildDir}/tmp/preUninstall-dai-eventsim.sh")
    postUninstall file("${buildDir}/tmp/daemon-reload.sh")
    postInstall   file("${buildDir}/tmp/daemon-reload.sh")

    into("/")

    from("${buildDir}/libs/eventsim.jar") {
        into("${lib_dir}")
    }
    from("${buildDir}/tmp/eventsim-server") {
        into(bin_dir)
        fileMode(0755)
    }
    from("${buildDir}/tmp/dai-eventsim.service") {
        into("/etc/systemd/system")
        fileMode = 0644
    }
    from("${buildDir}/tmp/eventsim-server.environment") {
        into(etc_dir)
        fileMode = 0644
    }

    link("/usr/bin/eventsim-server","${bin_dir}/eventsim-server")
}

task makeEventSimCliDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/postInstall-eventsim-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

cd ${python_dir}

/usr/bin/python3 -m pip install eventsim_cli-install-py3-none-any.whl

exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-eventsim-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

/usr/bin/python3 -m pip uninstall -y eventsim-cli

exit \$? 
"""
        exec {
            workingDir = "${projectDir}/cli_eventsim"
            errorOutput = standardOutput
            environment("DAIVER", "${pythonVersion}")
            commandLine "python3", "setup-eventsim.py", "bdist_wheel"
        }
        copy {
            from("${projectDir}/cli_eventsim/dist/")
            into("${buildDir}/tmp")
        }
        delete("${projectDir}/cli_eventsim/dist", "${projectDir}/cli_eventsim/eventsim_cli.egg-info",
                "${projectDir}/cli_eventsim/build")
    }
    summary = 'The DAI EventSim CLI Installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-eventsim-cli"

    preUninstall  file("${buildDir}/tmp/preUninstall-eventsim-cli.sh")
    postInstall   file("${buildDir}/tmp/postInstall-eventsim-cli.sh")

    into("/")

    from("${buildDir}/tmp/eventsim_cli-${pythonVersion}-py3-none-any.whl") {
        into(python_dir)
        rename("eventsim_cli-${pythonVersion}-py3-none-any.whl", "eventsim_cli-install-py3-none-any.whl")
    }
    from("${projectDir}/cli_eventsim/eventsim") {
        into(bin_dir)
        fileMode(0700)
    }

    link("/usr/bin/eventsim", "${bin_dir}/eventsim")
}

task makeEventSimCliRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/postInstall-eventsim-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

cd ${python_dir}

/usr/bin/python3 -m pip install eventsim_cli-install-py3-none-any.whl

exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-eventsim-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

/usr/bin/python3 -m pip uninstall -y eventsim-cli

exit \$? 
"""
        exec {
            workingDir = "${projectDir}/cli_eventsim"
            errorOutput = standardOutput
            environment("DAIVER", "${pythonVersion}")
            commandLine "python3", "setup-eventsim.py", "bdist_wheel"
        }
        copy {
            from("${projectDir}/cli_eventsim/dist/")
            into("${buildDir}/tmp")
        }
        delete("${projectDir}/cli_eventsim/dist", "${projectDir}/cli_eventsim/eventsim_cli.egg-info",
                "${projectDir}/cli_eventsim/build")
    }
    summary = 'The DAI EventSim CLI Installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-eventsim-cli"

    preUninstall  file("${buildDir}/tmp/preUninstall-eventsim-cli.sh")
    postInstall   file("${buildDir}/tmp/postInstall-eventsim-cli.sh")

    into("/")

    from("${buildDir}/tmp/eventsim_cli-${pythonVersion}-py3-none-any.whl") {
        into(python_dir)
        rename("eventsim_cli-${pythonVersion}-py3-none-any.whl", "eventsim_cli-install-py3-none-any.whl")
    }
    from("${projectDir}/cli_eventsim/eventsim") {
        into(bin_dir)
        fileMode(0700)
    }

    link("/usr/bin/eventsim", "${bin_dir}/eventsim")
}

task makeCliDeb(type: Deb) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/postInstall-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

cd ${python_dir}

/usr/bin/python3 -m pip install ucs_cli-install-py3-none-any.whl

exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

/usr/bin/python3 -m pip uninstall -y ucs-cli

exit \$? 
"""
        exec {
            workingDir = "${projectDir}/cli"
            errorOutput = standardOutput
            environment("DAIVER", "${pythonVersion}")
            commandLine "python3", "setup.py", "bdist_wheel"
        }
        copy {
            from("${projectDir}/cli/dist/")
            into("${buildDir}/tmp")
        }
        delete("${projectDir}/cli/dist", "${projectDir}/cli/ucs_cli.egg-info",
                "${projectDir}/cli/build")
    }
    summary = 'The DAI CLI Installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-cli"

    preUninstall  file("${buildDir}/tmp/preUninstall-cli.sh")
    postInstall   file("${buildDir}/tmp/postInstall-cli.sh")

    into("/")

    from("${buildDir}/tmp/ucs_cli-${pythonVersion}-py3-none-any.whl") {
        into(python_dir)
        rename("ucs_cli-${pythonVersion}-py3-none-any.whl", "ucs_cli-install-py3-none-any.whl")
    }
    from("${projectDir}/cli/ucs") {
        into(bin_dir)
        fileMode(0700)
    }
    from("${projectDir}/cli/ucs_completion.sh") {
        into("etc/bash_completion.d")
        fileMode(0755)
    }

    link("/usr/bin/ucs", "${bin_dir}/ucs")
}

task makeCliRpm(type: Rpm) {
    doFirst {
        new File((String)"${buildDir}/tmp").mkdirs()
        new File((String)"${buildDir}/tmp/postInstall-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

cd ${python_dir}

/usr/bin/python3 -m pip install ucs_cli-install-py3-none-any.whl

exit \$?
"""
        new File((String)"${buildDir}/tmp/preUninstall-cli.sh").text = """#!/bin/bash
# Copyright (C) ${thisYear} Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

/usr/bin/python3 -m pip uninstall -y ucs-cli

exit \$? 
"""
        exec {
            workingDir = "${projectDir}/cli"
            errorOutput = standardOutput
            environment("DAIVER", "${pythonVersion}")
            commandLine "python3", "setup.py", "bdist_wheel"
        }
        copy {
            from("${projectDir}/cli/dist/")
            into("${buildDir}/tmp")
        }
        delete("${projectDir}/cli/dist", "${projectDir}/cli/ucs_cli.egg-info",
                "${projectDir}/cli/build")
    }
    summary = 'The DAI CLI Installer.'
    release = "${packageRelease}"
    version = "${packageVersion}".split("-")[0]

    os = 'LINUX'
    type = 'BINARY'
    user = 'root'
    fileMode = 0600
    dirMode = 0700

    packageName = "dai-cli"

    preUninstall  file("${buildDir}/tmp/preUninstall-cli.sh")
    postInstall   file("${buildDir}/tmp/postInstall-cli.sh")

    into("/")

    from("${buildDir}/tmp/ucs_cli-${pythonVersion}-py3-none-any.whl") {
        into(python_dir)
        rename("ucs_cli-${pythonVersion}-py3-none-any.whl", "ucs_cli-install-py3-none-any.whl")
    }
    from("${projectDir}/cli/ucs") {
        into(bin_dir)
        fileMode(0700)
    }
    from("${projectDir}/cli/ucs_completion.sh") {
        into("etc/bash_completion.d")
        fileMode(0755)
    }

    link("/usr/bin/ucs", "${bin_dir}/ucs")
}

task makeAllArtifacts {
    doFirst {
        file("${buildDir}/distributions").mkdirs()
    }
    dependsOn subprojects.jar
    def rpms = [ "make3rdPartyRpm", "makeVoltDBSchemaSetupRpm", "makePostgresSchemaSetupRpm", "makeDaiRpm",
                 "makeEventSimConfigRpm", "makeHw1ConfigRpm", "makeHw2ConfigRpm", "makeHw3ConfigRpm",
                 "makeEventSimServerRpm", "makeEventSimCliRpm", "makeCliRpm" ]
    def debs = [ "make3rdPartyDeb", "makeVoltDBSchemaSetupDeb", "makePostgresSchemaSetupDeb", "makeDaiDeb",
                 "makeEventSimConfigDeb", "makeHw1ConfigDeb", "makeHw2ConfigDeb", "makeHw3ConfigDeb",
                 "makeEventSimServerDeb", "makeEventSimCliDeb", "makeCliDeb" ]
    def cleanup = [ "cleanupDeb" ]
    def packages = rpms
    if(INCLUDE_DEBIAN)
        packages = packages + debs + cleanup
    println("*** BUILING PACKAGES: " + packages)
    finalizedBy packages
}
rootProject.jar.finalizedBy(makeAllArtifacts)

task dockerBuild(type: Exec) {
    group = 'build'
    workingDir = "${projectDir}"
    commandLine "docker-build/docker-build.sh", "build"
}
